import { join } from 'node:path'
import { analyzeFlow } from '../registry'
import { analyzeTriggerSubscriptions, buildTriggerIndex } from '../registry/triggerAnalyzer'

/**
 * Generate the queue registry template content
 */
export function generateRegistryTemplate(registry: any): string {
  return `// auto-generated by nuxt-queue
export const registry = ${JSON.stringify(registry, null, 2)};

export const useQueueRegistry = () => registry;

export default useQueueRegistry;
`
}

/**
 * Generate the worker handlers template content
 */
export function generateHandlersTemplate(registry: any): string {
  const regWorkers = (registry?.workers || []) as any[]
  const lines: string[] = []
  const entries: string[] = []

  regWorkers
    .filter((w: any) => w?.kind === 'ts' && (w?.runtype ? w.runtype !== 'task' : (registry?.runner?.ts?.isolate !== 'task')))
    .forEach((w: any, i: number) => {
      const varName = `h${i}`
      const src = (w && (w.absPath || w.abs || (w.cwd && w.file && join(w.cwd, w.file)) || w.entry || w.path)) || ''
      if (!src) return
      const importPath = String(src)
      lines.push(`import ${varName} from '${importPath}'`)
      const queue = String(w?.queue?.name || `w${i}`)
      const id = String(w?.id || `w${i}`)
      const absPath = importPath
      entries.push(`{ queue: '${queue}', id: '${id}', absPath: '${absPath}', handler: ${varName} }`)
    })

  return `// auto-generated by nuxt-queue
${lines.join('\n')}

export const handlers = [
  ${entries.join(',\n  ')}
]

export const useWorkerHandlers = () => handlers;

export default useWorkerHandlers;
`
}

/**
 * Generate the analyzed flows template content
 */
export function generateAnalyzedFlowsTemplate(registry: any): string {
  const flows = registry?.flows || {}
  const workers = registry?.workers || []

  // Create a map of workerId -> worker metadata
  const workerMetaMap = new Map()
  for (const worker of workers) {
    workerMetaMap.set(worker.id, {
      runtime: worker.kind === 'py' ? 'python' : 'nodejs',
      runtype: (worker as any).runtype,
      queue: (worker as any).queue,
      worker: (worker as any).worker,
      emits: (worker.flow as any)?.emits,
    })
  }

  // Analyze all flows
  const analyzedFlows = Object.entries(flows).map(([id, meta]: any) => {
    // Add runtime to entry
    const workerMeta = meta?.entry ? workerMetaMap.get(meta.entry.workerId) : undefined
    const entry = meta?.entry
      ? {
          ...meta.entry,
          runtime: workerMeta?.runtime,
          runtype: workerMeta?.runtype,
          emits: workerMeta?.emits,
        }
      : undefined

    // Add runtime to each step
    const steps = meta?.steps
      ? Object.fromEntries(
          Object.entries(meta.steps).map(([stepName, stepData]: [string, any]) => {
            const stepWorkerMeta = workerMetaMap.get(stepData.workerId)
            return [
              stepName,
              {
                ...stepData,
                runtime: stepWorkerMeta?.runtime,
                runtype: stepWorkerMeta?.runtype,
                emits: stepWorkerMeta?.emits,
              },
            ]
          }),
        )
      : {}

    const flowMeta = {
      id,
      entry,
      steps,
    }

    // Analyze flow structure
    const analyzed = analyzeFlow(flowMeta)

    return {
      ...flowMeta,
      analyzed: {
        levels: analyzed.levels,
        maxLevel: analyzed.maxLevel,
        steps: analyzed.steps,
      },
    }
  })

  return `// auto-generated by nuxt-queue
export const analyzedFlows = ${JSON.stringify(analyzedFlows, null, 2)};

export const useAnalyzedFlows = () => analyzedFlows;

export default useAnalyzedFlows;
`
}

/**
 * Generate the trigger registry template content
 * Analyzes and extracts trigger subscriptions from worker configs
 */
export function generateTriggerRegistryTemplate(registry: any): string {
  const workers = registry?.workers || []

  // Analyze at build time and generate a static snapshot
  const subscriptions = analyzeTriggerSubscriptions(workers)
  const index = buildTriggerIndex(subscriptions)

  // Convert Maps to plain objects for serialization
  const triggerToFlows: Record<string, any[]> = {}
  for (const [trigger, subs] of index.triggerToFlows.entries()) {
    triggerToFlows[trigger] = Array.from(subs)
  }

  const flowToTriggers: Record<string, string[]> = {}
  for (const [flow, triggers] of index.flowToTriggers.entries()) {
    flowToTriggers[flow] = Array.from(triggers)
  }

  const triggerRegistry = {
    subscriptions,
    index: {
      triggerToFlows,
      flowToTriggers,
    },
    compiledAt: new Date().toISOString(),
  }

  return `// auto-generated by nuxt-queue
export const triggerRegistry = ${JSON.stringify(triggerRegistry, null, 2)};

export const useTriggerRegistry = () => triggerRegistry;

export default useTriggerRegistry;
`
}

/**
 * Generate adapter type definitions template
 * Used by external adapter packages to import types
 */
export function generateAdapterTypesTemplate(resolverFn: (path: string) => string): string {
  return `// Auto-generated adapter type definitions
// External adapter packages can import these types

// Queue Adapter
export type {
  QueueAdapter,
  JobInput,
  Job,
  JobsQuery,
  JobOptions,
  JobState,
  ScheduleOptions,
  JobCounts,
  QueueEvent,
  WorkerHandler,
  WorkerContext,
  WorkerOptions,
} from ${JSON.stringify(resolverFn('./runtime/adapters/interfaces/queue'))}

// Stream Adapter
export type {
  StreamAdapter,
  StreamEvent,
  SubscribeOptions,
  SubscriptionHandle,
} from ${JSON.stringify(resolverFn('./runtime/adapters/interfaces/stream'))}

// Store Adapter
export type {
  StoreAdapter,
  EventRecord,
  EventReadOptions,
  EventSubscription,
  ListOptions,
} from ${JSON.stringify(resolverFn('./runtime/adapters/interfaces/store'))}

// Event Types
export type {
  EventType,
  BaseEvent,
  StepEvent,
  FlowStartEvent,
  FlowCompletedEvent,
  FlowFailedEvent,
  FlowCancelEvent,
  FlowStalledEvent,
  StepStartedEvent,
  StepCompletedEvent,
  StepFailedEvent,
  StepRetryEvent,
  LogEvent,
  EmitEvent,
  StateEvent,
  FlowEvent,
} from ${JSON.stringify(resolverFn('./runtime/events/types'))}

// Adapter Registry
export type { AdapterRegistry } from ${JSON.stringify(resolverFn('./runtime/adapters/registry'))}`
}
