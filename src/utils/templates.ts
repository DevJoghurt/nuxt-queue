import { join } from 'node:path'
import { analyzeFlow } from '../registry'

/**
 * Generate the queue registry template content
 */
export function generateRegistryTemplate(registry: any): string {
  return `// auto-generated by nuxt-queue
export const registry = ${JSON.stringify(registry, null, 2)};

export const useQueueRegistry = () => registry;

export default useQueueRegistry;
`
}

/**
 * Generate the worker handlers template content
 */
export function generateHandlersTemplate(registry: any): string {
  const regWorkers = (registry?.workers || []) as any[]
  const lines: string[] = []
  const entries: string[] = []

  // Keep handlers for TS in-process (and anything not explicitly marked as task)
  // Python entries are ignored here; they use a different runner.
  regWorkers
    .filter((w: any) => w?.kind === 'ts' && (w?.runtype ? w.runtype !== 'task' : (registry?.runner?.ts?.isolate !== 'task')))
    .forEach((w: any, i: number) => {
      const varName = `h${i}`
      const src = (w && (w.absPath || w.abs || (w.cwd && w.file && join(w.cwd, w.file)) || w.entry || w.path)) || ''
      if (!src) return
      // Import using the real absolute path including extension to avoid resolution issues
      const importPath = String(src)
      lines.push(`import ${varName} from '${importPath}'`)
      const queue = String(w?.queue?.name || `w${i}`)
      const id = String(w?.id || `w${i}`)
      const absPath = importPath
      entries.push(`{ queue: '${queue}', id: '${id}', absPath: '${absPath}', handler: ${varName} }`)
    })

  return `// auto-generated by nuxt-queue
${lines.join('\n')}

export const handlers = [
  ${entries.join(',\n  ')}
] 

export const useWorkerHandlers = () => handlers;

export default useWorkerHandlers;
`
}

/**
 * Generate the analyzed flows template content
 */
export function generateAnalyzedFlowsTemplate(registry: any): string {
  const flows = registry?.flows || {}
  const workers = registry?.workers || []

  // Create a map of workerId -> worker metadata
  const workerMetaMap = new Map()
  for (const worker of workers) {
    workerMetaMap.set(worker.id, {
      runtime: worker.kind === 'py' ? 'python' : 'nodejs',
      runtype: (worker as any).runtype,
      queue: (worker as any).queue,
      worker: (worker as any).worker,
      emits: (worker.flow as any)?.emits,
    })
  }

  // Analyze all flows
  const analyzedFlows = Object.entries(flows).map(([id, meta]: any) => {
    // Add runtime to entry
    const workerMeta = meta?.entry ? workerMetaMap.get(meta.entry.workerId) : undefined
    const entry = meta?.entry
      ? {
          ...meta.entry,
          runtime: workerMeta?.runtime,
          runtype: workerMeta?.runtype,
          emits: workerMeta?.emits,
        }
      : undefined

    // Add runtime to each step
    const steps = meta?.steps
      ? Object.fromEntries(
          Object.entries(meta.steps).map(([stepName, stepData]: [string, any]) => {
            const stepWorkerMeta = workerMetaMap.get(stepData.workerId)
            return [
              stepName,
              {
                ...stepData,
                runtime: stepWorkerMeta?.runtime,
                runtype: stepWorkerMeta?.runtype,
                emits: stepWorkerMeta?.emits,
              },
            ]
          }),
        )
      : {}

    const flowMeta = {
      id,
      entry,
      steps,
    }

    // Analyze flow structure
    const analyzed = analyzeFlow(flowMeta)

    return {
      ...flowMeta,
      analyzed: {
        levels: analyzed.levels,
        maxLevel: analyzed.maxLevel,
        steps: analyzed.steps,
      },
    }
  })

  return `// auto-generated by nuxt-queue
export const analyzedFlows = ${JSON.stringify(analyzedFlows, null, 2)};

export const useAnalyzedFlows = () => analyzedFlows;

export default useAnalyzedFlows;
`
}
