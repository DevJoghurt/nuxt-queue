import { join } from 'node:path'
import {
  defineNuxtModule,
  createResolver,
  addServerScanDir,
  addServerImports,
  addTemplate,
  addImportsDir,
  addComponent,
  addComponentsDir,
} from '@nuxt/kit'
import defu from 'defu'
import { compileRegistryFromServerWorkers, type LayerInfo } from './registry'
import type { ModuleOptions, QueueOptions, RegisteredWorker } from './types'
import { debounce } from 'perfect-debounce'
import type {} from '@nuxt/schema'

const meta = {
  name: 'queue',
  version: '0.1',
  configKey: 'queue',
}

declare module '@nuxt/schema' {
  interface RuntimeConfig {
    queue: {
      runtimeDir: string
      redis: ModuleOptions['redis']
      queues: Record<string, Omit<QueueOptions, 'connection'>>
      workers: RegisteredWorker[]
      // compiled registry snapshot (JSON-safe)
      registry?: any
      state?: {
        name?: 'redis' | 'postgres'
        namespace?: string
        autoScope?: 'always' | 'flow' | 'never'
        cleanup?: {
          strategy?: 'never' | 'immediate' | 'ttl' | 'on-complete'
          ttlMs?: number
        }
      }
      eventStore?: {
        name?: 'redis' | 'postgres' | 'memory'
        mode?: 'streams' | 'fallback'
        streams?: any
      }
    }
  }
}

export default defineNuxtModule<ModuleOptions>({
  meta,
  defaults: {
    dir: 'queues',
    runtimeDir: '',
    ui: false,
    redis: {
      host: '127.0.0.1',
      port: 6379,
    },
  },
  moduleDependencies: {
    'json-editor-vue/nuxt': {
      version: '0.18.1',
    },
  },
  async setup(options, nuxt) {
    const { resolve } = createResolver(import.meta.url)

    addServerScanDir(resolve('./runtime/server'))

    addImportsDir(resolve('./runtime/composables'))

    if (options.ui) {
      addComponentsDir({
        path: resolve('./runtime/components'),
        prefix: 'Queue',
      })

      addComponent({
        name: 'QueueApp',
        filePath: resolve('./runtime/app/index.vue'),
        global: true,
      })

      // Register additional UI pages as components to avoid local TS imports
      addComponent({
        name: 'QueueEvents',
        filePath: resolve('./runtime/app/events/index.vue'),
        global: true,
      })

      addComponent({
        name: 'QueueFlows',
        filePath: resolve('./runtime/app/flows/index.vue'),
        global: true,
      })
    }

    // add jsoneditor to vite optimize -> for esm support
    nuxt.options.vite.optimizeDeps = defu(nuxt.options.vite.optimizeDeps, {
      include: ['vanilla-jsoneditor'],
    })

    nuxt.hook('nitro:config', (nitro) => {
      // Ensure Redis storage is configured for unstorage so StateProvider persists to Redis.
      nitro.storage = defu(nitro.storage || {}, {
        redis: {
          driver: 'redis',
          host: options.redis?.host,
          port: options.redis?.port,
          username: options.redis?.username,
          password: options.redis?.password,
          // base namespace handled in provider; keep storage base default
        },
      })
    })

    const runtimeConfig = nuxt.options.runtimeConfig

    runtimeConfig.queue = defu(runtimeConfig.queue || {}, {
      redis: options.redis,
      queues: {},
      workers: [],
      state: { name: 'redis', namespace: 'nq', autoScope: 'always', cleanup: { strategy: 'never' } },
      eventStore: { name: 'redis' },
    }) as any

    // Build real registry snapshot from disk
    const layerInfos: LayerInfo[] = nuxt.options._layers.map(l => ({
      rootDir: l.config.rootDir,
      serverDir: l.config?.serverDir || join(l.config.rootDir, 'server'),
    }))
    const compiledRegistry = await compileRegistryFromServerWorkers(layerInfos, options?.dir || 'queues')
    // augment with defaults and metadata
    const compiledWithMeta = defu(compiledRegistry, {
      version: 1,
      compiledAt: new Date().toISOString(),
      provider: { name: 'bullmq' },
      logger: { name: 'console', level: 'info' },
      state: { name: 'redis', namespace: 'nq', autoScope: 'always', cleanup: { strategy: 'never' } },
      eventStore: { name: 'redis' },
      runner: { ts: { isolate: 'inprocess' }, py: { enabled: false, cmd: 'python3', importMode: 'file' } },
      workers: [],
      flows: {},
      eventIndex: {},
    })
    // Ensure plain JSON snapshot to avoid readonly/proxy issues in Nitro normalization
    const compiledSnapshot = JSON.parse(JSON.stringify(compiledWithMeta))
    // Keep a mutable reference for dev updates
    let lastCompiledRegistry = compiledSnapshot

    // Emit a template so changes trigger HMR/rebuilds even if only runtimeConfig changes
    addTemplate({
      filename: 'queue-registry.ts',
      write: true,
      getContents: () => `// auto-generated by nuxt-queue
  export const registry = ${JSON.stringify(lastCompiledRegistry, null, 2)} as const;

  export type QueueRegistry = typeof registry;

  export const useQueueRegistry = (): QueueRegistry => registry;

  export default useQueueRegistry;
  `,
    })

    // Template: bundle worker handlers into Nitro context so imports work at runtime
    addTemplate({
      filename: 'worker-handlers.ts',
      write: true,
      getContents: () => {
        // Build imports for discovered in-process workers from the compiled registry
        const regWorkers = (lastCompiledRegistry?.workers || []) as any[]
        const lines: string[] = []
        const mappings: string[] = []
        // Keep handlers for TS in-process (and anything not explicitly marked as task)
        // Python entries are ignored here; they use a different runner.
        regWorkers
          .filter((w: any) => w?.kind === 'ts' && (w?.runtype ? w.runtype !== 'task' : (lastCompiledRegistry?.runner?.ts?.isolate !== 'task')))
          .forEach((w: any, i: number) => {
            const varName = `h${i}`
            const src = (w && (w.absPath || w.abs || (w.cwd && w.file && join(w.cwd, w.file)) || w.entry || w.path)) || ''
            if (!src) return
            // Import using the real absolute path including extension to avoid resolution issues
            const importPath = String(src)
            lines.push(`import ${varName} from '${importPath}'`)
            const key = String(w?.name || w?.queue || `w${i}`)
            mappings.push(`'${key}': ${varName}`)
          })
        return `// auto-generated by nuxt-queue
${lines.join('\n')}

export const handlers = {
  ${mappings.join(',\n  ')}
} as const

export type WorkerHandlers = typeof handlers;

export const useWorkerHandlers = (): WorkerHandlers => handlers;

export default useWorkerHandlers;
`
      },
    })

    // add composables
    addServerImports([{
      name: 'useQueueRegistry',
      as: '$useQueueRegistry',
      from: resolve(nuxt.options.buildDir, 'queue-registry'),
    }, {
      name: 'useLoggerProvider',
      as: '$useLoggerProvider',
      from: resolve('./runtime/server/providers/logger/index'),
    }, {
      name: 'setLoggerProvider',
      as: '$setLoggerProvider',
      from: resolve('./runtime/server/providers/logger/index'),
    }, {
      name: 'useQueueProvider',
      as: '$useQueueProvider',
      from: resolve('./runtime/server/providers/queue/index'),
    }, {
      name: 'setQueueProvider',
      as: '$setQueueProvider',
      from: resolve('./runtime/server/providers/queue/index'),
    }, {
      name: 'useStateProvider',
      as: '$useStateProvider',
      from: resolve('./runtime/server/providers/state/index'),
    }, {
      name: 'setStateProvider',
      as: '$setStateProvider',
      from: resolve('./runtime/server/providers/state/index'),
    }, {
      name: 'useWorkerHandlers',
      as: '$useWorkerHandlers',
      from: resolve(nuxt.options.buildDir, 'worker-handlers'),
    }, {
      name: 'useEventStoreProvider',
      as: '$useEventStoreProvider',
      from: resolve('./runtime/server/providers/events/index'),
    }, {
      name: 'setEventStoreProvider',
      as: '$setEventStoreProvider',
      from: resolve('./runtime/server/providers/events/index'),
    }, {
      name: 'useEventBus',
      as: '$useEventBus',
      from: resolve('./runtime/server/providers/events/bus'),
    }, {
      name: 'useStreamNames',
      as: '$useStreamNames',
      from: resolve('./runtime/server/providers/events/streams'),
    }])

    // Small helper to refresh registry and re-generate app (dev)
    const refreshRegistry = async (reason: string, changedPath?: string) => {
      const queuesRel = options?.dir || 'queues'
      const updatedRegistry = await compileRegistryFromServerWorkers(layerInfos, queuesRel)
      // No merging: the compiled registry is the single source of truth
      lastCompiledRegistry = JSON.parse(JSON.stringify(defu(updatedRegistry, {
        version: 1,
        compiledAt: new Date().toISOString(),
        provider: { name: 'bullmq' },
        logger: { name: 'console', level: 'info' },
        state: { name: 'redis', namespace: 'nq' },
        eventStore: { name: 'redis' },
        runner: { ts: { isolate: 'inprocess' }, py: { enabled: false, cmd: 'python3', importMode: 'file' } },
        workers: [],
        flows: {},
        eventIndex: {},
      })))
      console.log(`[nuxt-queue] registry refreshed (${reason})`, changedPath || '')
      await nuxt.callHook('builder:generateApp')
    }

    if (nuxt.options.dev) {
      // Watch for changes in queues and rebuild registry to keep runtime config fresh
      const queuesRel = options?.dir || 'queues'
      const jobFilter = (p: string) => {
        const norm = p.replace(/\\/g, '/')
        return norm.includes(`/server/${queuesRel}/`)
      }

      // Add a Vite dev-server watcher to ensure changes are caught even if builder:watch doesn't fire
      nuxt.hook('vite:serverCreated', (server) => {
        const watchDirs: string[] = []
        for (const layer of nuxt.options._layers) {
          const serverDir = layer.config?.serverDir || join(layer.config.rootDir, 'server')
          watchDirs.push(join(serverDir, queuesRel))
        }
        // Start watching directories
        server.watcher.add(watchDirs)
        const debouncedRefresh = debounce(async (event: string, file: string) => {
          const norm = file.replace(/\\/g, '/')
          if (!jobFilter(norm)) return
          await refreshRegistry(`vite:${event}`, file)
        }, 100)
        server.watcher.on('all', async (event, file) => {
          debouncedRefresh(event, file)
        })
        console.log('[nuxt-queue] vite watcher attached for', watchDirs)
      })
    }
  },
})
